<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net https://esm.sh 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com https://esm.sh;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://*.ardrive.net;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
    rel="stylesheet"/>
  <style>
    :root {
      --neon: #00ffe1;
      --neon-dim: rgba(0,255,225,0.2);
      --text-light: #e0e0e0;
      --card-bg: rgba(255,255,255,0.05);
      --radius: 16px;
      --gap: 1.5rem;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      background: radial-gradient(circle at center,#1a1a3d,#0a0a1f);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      padding: var(--gap);
      line-height:1.4;
    }
    .brand {
      text-align:center;
      font-size:2.5rem;
      font-weight:700;
      color:var(--neon);
      text-shadow:0 0 8px var(--neon),0 0 16px var(--neon);
      margin-bottom:var(--gap);
      letter-spacing:2px;
    }
    #wallet-button {
      position:fixed; top:var(--gap); right:var(--gap);
      padding:.6rem 1.2rem;
      border:2px solid var(--neon);
      background:transparent; color:var(--neon);
      border-radius:var(--radius);
      font-weight:500; cursor:pointer;
      transition:background var(--transition),color var(--transition);
      z-index:10;
    }
    #wallet-button:hover { background:var(--neon-dim); color:#fff }
    .lower-section {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(320px,1fr));
      gap:var(--gap);
    }
    .box {
      background:var(--card-bg);
      backdrop-filter:blur(12px);
      border:1px solid rgba(255,255,255,0.1);
      border-radius:var(--radius);
      padding:var(--gap);
      display:flex; flex-direction:column;
      transition:transform var(--transition),box-shadow var(--transition);
    }
    .box:hover {
      transform:translateY(-6px);
      box-shadow:0 8px 32px rgba(0,0,0,0.6);
    }
    h1 {
      font-size:1.8rem; font-weight:700;
      color:var(--neon); text-align:center;
      margin-bottom:1rem;
      text-shadow:0 0 4px var(--neon);
    }
    label {
      font-weight:500; margin-bottom:.5rem;
      color:var(--text-light);
    }
    select,input {
      width:100%; padding:.6rem; margin-bottom:1rem;
      border:1px solid rgba(255,255,255,0.2);
      border-radius:8px;
      background:rgba(255,255,255,0.03);
      color:var(--text-light);
      font-size:1rem;
      transition:border var(--transition);
    }
    select:focus,input:focus { outline:none; border-color:var(--neon) }
    button {
      padding:.75rem; border:2px solid var(--neon);
      background:transparent; color:var(--neon);
      border-radius:8px; font-weight:500;
      cursor:pointer;
      transition:background var(--transition),color var(--transition);
      margin:0 auto;
    }
    button:hover { background:var(--neon-dim); color:#fff }
    .info { text-align:center; margin:.75rem 0; font-size:.95rem }
  </style>
</head>
<body>
  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>

  <div class="lower-section">
    <div class="box">
      <h1>Mint NFT</h1>
      <label for="power-select">Select Power & Price</label>
      <select id="power-select">
        <option value="1">1 — $S10</option>
        <option value="2">2 — $S20</option>
        <option value="3">3 — $S30</option>
        <option value="4">4 — $S40</option>
        <option value="5">5 — $S50</option>
        <option value="6">6 — $S60</option>
        <option value="7">7 — $S70</option>
        <option value="8">8 — $S80</option>
        <option value="9">9 — $S90</option>
        <option value="10">10 — $S100</option>
      </select>
      <button id="mint-button">Mint Now</button>
      <div id="status" class="info">Disconnected</div>
    </div>

    <div class="box">
      <h1>Stake & Unstake</h1>
      <label for="stake-select">Your NFTs (Power)</label>
      <select id="stake-select" multiple size="5"></select>
      <button id="stake-button">Stake Selected</button>

      <label for="unstake-select">Staked NFTs</label>
      <select id="unstake-select" multiple size="5"></select>
      <button id="unstake-button">Unstake Selected</button>

      <div id="staked-info" class="info">Staked NFTs: 0 | Power: 0</div>
      <div id="pending-rewards" class="info">Rewards: 0 S</div>
      <button id="claim-button">Claim Rewards</button>
      <div id="stake-status" class="info"></div>
    </div>

    <div class="box">
      <h1>Coming Soon</h1>
      <p class="info">Redeem utilities launching shortly!</p>
    </div>
  </div>

  <script type="module">
    // 1) ethers.js
    import { ethers } 
      from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    // 2) Wagmi core bundle with publicProvider
    import {
      createClient,
      configureChains,
      watchAccount,
      watchNetwork,
      publicProvider
    } from 'https://esm.sh/@wagmi/core@2.21.2?bundle';

    // 3) deep import of the injected connector factory
    import { injected } 
      from 'https://esm.sh/@wagmi/connectors@0.4.14/connectors/injected?bundle';

    // Sonic Testnet config
    const sonicTestnet = {
      id:14601,
      name:'Sonic Testnet',
      network:'sonic-testnet',
      nativeCurrency:{name:'Sonic',symbol:'S',decimals:18},
      rpcUrls:{default:'https://rpc.testnet.soniclabs.com'}
    };

    // build Wagmi client
    const { chains, provider } = configureChains(
      [sonicTestnet],
      [publicProvider()]
    );
    const connector = injected({ chains });
    const client    = createClient({
      autoConnect: true,
      connectors:  [connector],
      provider
    });

    // Contract addresses & ABIs
    const NFT_ADDRESS     = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;

    const NFT_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)",
      "function tokenPower(uint256) view returns (uint8)",
      "function feeForPower(uint8) view returns (uint256)",
      "function mint(uint8) payable",
      "function isApprovedForAll(address,address) view returns (bool)",
      "function setApprovalForAll(address,bool)"
    ];
    const STAKING_ABI = [
      "function stake(uint256[])",
      "function unstake(uint256[])",
      "function claimRewards()",
      "function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])"
    ];

    let signer, account;
    let nftContract, stakingContract, stakingRead;

    // disable UI until connected
    document.getElementById('mint-button').disabled  = true;
    document.getElementById('claim-button').disabled = true;

    // connect wallet handler
    document.getElementById('wallet-button').onclick = async () => {
      console.log('🔹 Connect clicked');
      try {
        const data = await client.connect({ connector });
        console.log('✅ Connected:', data);
      } catch (err) {
        console.error('❌ Connection failed:', err);
      }
    };

    watchAccount(({ address, isConnected }) => {
      if (isConnected && address) {
        account = address;
        initEthers();
      } else {
        tearDown();
      }
    });
    watchNetwork(({ chain }) => {
      if (chain?.id !== REQUIRED_CHAIN_ID) {
        document.getElementById('status').textContent =
          'Please switch to Sonic Testnet';
      }
    });

    async function initEthers() {
      const wagmiProv = provider();
      const web3p     = new ethers.providers.Web3Provider(wagmiProv, 'any');
      signer          = web3p.getSigner();

      document.getElementById('wallet-button').textContent =
        '…' + account.slice(-4);
      document.getElementById('status').textContent = 'Connected';
      document.getElementById('mint-button').disabled  = false;
      document.getElementById('claim-button').disabled = false;

      nftContract     = new ethers.Contract(NFT_ADDRESS,     NFT_ABI,     signer);
      stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead     = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, web3p);

      attachHandlers();
      await refreshAll();
    }

    function tearDown() {
      signer = account = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          document.getElementById('status').textContent = 'Minting…';
          const cost = await nftContract.feeForPower(p);
          const tx   = await nftContract.mint(p, { value: cost });
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await refreshAll();
        } catch (e) {
          document.getElementById('status').textContent = e.message;
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('stake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          if (!(await nftContract.isApprovedForAll(account, STAKING_ADDRESS))) {
            document.getElementById('stake-status').textContent = 'Approving…';
            await (await nftContract.setApprovalForAll(STAKING_ADDRESS, true)).wait();
          }
          document.getElementById('stake-status').textContent = 'Staking…';
          await (await stakingContract.stake(ids)).wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('unstake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          await (await stakingContract.unstake(ids)).wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          await (await stakingContract.claimRewards()).wait();
          document.getElementById('stake-status').textContent = 'Claimed!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };
    }

    async function refreshAll() {
      await populateOwned();
      await populateStaked();
      await updateStats();
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      const bal = await nftContract.balanceOf(account);
      for (let i = 0; i < bal; i++) {
        const id = await nftContract.tokenOfOwnerByIndex(account, i);
        const p  = await nftContract.tokenPower(id);
        const o  = document.createElement('option');
        o.value      = id.toString();
        o.textContent = `#${id} (Power: ${p})`;
        sel.append(o);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [,, , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id,i) => {
          const o = document.createElement('option');
          o.value      = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        console.error('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw] =
          await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent =
          `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent =
          `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
      } catch (e) {
        console.error('updateStats failed', e);
      }
    }
  </script>
</body>
</html>
