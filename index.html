<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net https://esm.sh 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://*.ardrive.net;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link 
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" 
    rel="stylesheet"/>
  <style>
    /* … your existing neon/glassmorphic CSS … */
  </style>
</head>
<body>
  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>
  <!-- … rest of your HTML (banner, mint card, staking card, socials) … -->

  <script type="module">
    // ethers.js from jsDelivr
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    // Wagmi core as one ESM bundle
    import {
      createClient,
      configureChains,
      watchAccount,
      watchNetwork
    } from 'https://esm.sh/@wagmi/core@2.21.2?bundle';

    import { publicProvider } from 'https://esm.sh/@wagmi/core@2.21.2/providers/public?bundle';
    import { InjectedConnector } from 'https://esm.sh/@wagmi/core@2.21.2/connectors/injected?bundle';

    // Sonic Testnet config
    const sonicTestnet = {
      id: 14601,
      name: 'Sonic Testnet',
      network: 'sonic-testnet',
      nativeCurrency: { name: 'Sonic', symbol: 'S', decimals: 18 },
      rpcUrls: { default: 'https://rpc.testnet.soniclabs.com' }
    };

    // build Wagmi client
    const { chains, provider } = configureChains(
      [sonicTestnet],
      [publicProvider()]
    );

    const injectedConnector = new InjectedConnector({ chains });
    const client = createClient({
      autoConnect: true,
      connectors: [injectedConnector],
      provider
    });

    // Addresses & ABIs
    const NFT_ADDRESS     = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;

    const NFT_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)",
      "function tokenPower(uint256) view returns (uint8)",
      "function feeForPower(uint8) view returns (uint256)",
      "function mint(uint8) payable",
      "function isApprovedForAll(address,address) view returns (bool)",
      "function setApprovalForAll(address,bool)"
    ];

    const STAKING_ABI = [
      "function stake(uint256[])",
      "function unstake(uint256[])",
      "function claimRewards()",
      "function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])"
    ];

    let signer, account;
    let nftContract, stakingContract, stakingRead;

    // disable buttons until connected
    document.getElementById('mint-button').disabled = true;
    document.getElementById('claim-button').disabled = true;

    // click handler with console logs
    document.getElementById('wallet-button').onclick = async () => {
      console.log('🔹 Connect clicked');
      try {
        const data = await client.connect({ connector: injectedConnector });
        console.log('✅ Wagmi.connect result:', data);
      } catch (err) {
        console.error('❌ Wagmi.connect error:', err);
      }
    };

    // respond to account & network changes
    watchAccount(({ address, isConnected }) => {
      if (isConnected && address) {
        account = address;
        initializeEthers();
      } else {
        disconnect();
      }
    });

    watchNetwork(({ chain }) => {
      if (chain?.id !== REQUIRED_CHAIN_ID) {
        document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
      }
    });

    async function initializeEthers() {
      const wagmiProvider = provider();
      const wsProvider   = new ethers.providers.Web3Provider(wagmiProvider, 'any');
      signer             = wsProvider.getSigner();

      document.getElementById('wallet-button').textContent = '…' + account.slice(-4);
      document.getElementById('status').textContent        = 'Connected';
      document.getElementById('mint-button').disabled      = false;
      document.getElementById('claim-button').disabled     = false;

      nftContract      = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
      stakingContract  = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead      = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, wsProvider);

      attachHandlers();
      await populateOwned();
      await populateStaked();
      await updateStats();
    }

    function disconnect() {
      signer = account = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          document.getElementById('status').textContent = 'Minting…';
          const cost  = await nftContract.feeForPower(p);
          const tx    = await nftContract.mint(p, { value: cost });
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('status').textContent = e.message;
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('stake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          if (!(await nftContract.isApprovedForAll(account, STAKING_ADDRESS))) {
            document.getElementById('stake-status').textContent = 'Approving…';
            const aTx = await nftContract.setApprovalForAll(STAKING_ADDRESS, true);
            await aTx.wait();
          }
          document.getElementById('stake-status').textContent = 'Staking…';
          const tx = await stakingContract.stake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('unstake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          const tx = await stakingContract.unstake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          const tx = await stakingContract.claimRewards();
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Claimed!';
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      const bal = await nftContract.balanceOf(account);
      for (let i = 0; i < bal; i++) {
        const id = await nftContract.tokenOfOwnerByIndex(account, i);
        const p  = await nftContract.tokenPower(id);
        const o  = document.createElement('option');
        o.value      = id.toString();
        o.textContent = `#${id} (Power: ${p})`;
        sel.append(o);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [, , , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id, i) => {
          const o = document.createElement('option');
          o.value      = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        console.error('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw] =
          await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent =
          `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent =
          `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
      } catch (e) {
        console.error('updateStats failed', e);
      }
    }
  </script>
</body>
</html>
