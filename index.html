<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://*.ardrive.net;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"/>
  <style>
    :root {
      --neon: #00ffe1;
      --neon-dim: rgba(0,255,225,0.2);
      --text-light: #e0e0e0;
      --card-bg: rgba(255,255,255,0.05);
      --radius: 16px;
      --gap: 1.5rem;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at center,#1a1a3d,#0a0a1f);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      padding: var(--gap);
      line-height: 1.4;
    }
    .brand {
      text-align: center;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--neon);
      text-shadow: 0 0 8px var(--neon), 0 0 16px var(--neon);
      margin-bottom: var(--gap);
      letter-spacing: 2px;
    }
    #wallet-button {
      position: fixed; top: var(--gap); right: var(--gap);
      padding: .6rem 1.2rem;
      border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: var(--radius);
      font-weight: 500; cursor: pointer;
      transition: background var(--transition), color var(--transition);
      z-index: 10;
    }
    #wallet-button:hover { background: var(--neon-dim); color: #fff; }
    .banner-wrapper {
      max-width: 300px; margin: 0 auto calc(var(--gap)*1.5);
      border-radius: var(--radius); overflow: hidden;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
    .banner-wrapper img { width: 100%; display: block; }
    .lower-section {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(320px,1fr));
      gap: var(--gap);
    }
    .box {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: var(--radius);
      padding: var(--gap);
      display: flex; flex-direction: column;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .box:hover {
      transform: translateY(-6px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    h1 {
      font-size: 1.8rem; font-weight: 700;
      color: var(--neon); text-align: center;
      margin-bottom: 1rem;
      text-shadow: 0 0 4px var(--neon);
    }
    label {
      font-weight: 500; margin-bottom: .5rem;
      color: var(--text-light);
    }
    select, input {
      width: 100%; padding: .6rem; margin-bottom: 1rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      color: var(--text-light);
      font-size: 1rem;
      transition: border var(--transition);
    }
    select:focus, input:focus { outline: none; border-color: var(--neon); }
    button {
      padding: .75rem; border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: 8px; font-weight: 500;
      cursor: pointer;
      transition: background var(--transition), color var(--transition);
      margin: 0 auto;
    }
    button:hover { background: var(--neon-dim); color: #fff; }
    .form-group {
      flex: 1; display: flex; flex-direction: column; align-items: center;
    }
    .info { text-align: center; margin: .75rem 0; font-size: .95rem; }
    #status, #stake-status {
      text-align: center; margin-top: .5rem;
      min-height: 1.2em; font-size: .9rem; color: var(--neon);
    }
    .socials { text-align: center; margin-top: var(--gap); }
    .socials a { margin: 0 .5rem; display: inline-block; }
    .socials img {
      width: 28px; height: 28px;
      filter: drop-shadow(0 0 4px var(--neon));
    }
    .debug { position: fixed; left: 12px; bottom: 12px; background: rgba(0,0,0,0.6); color: #fff; padding: .5rem .75rem; border-radius: 8px; font-size: .85rem; max-width: 40%; z-index: 9999; overflow: auto; max-height: 30vh; }
  </style>
</head>
<body>
  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>

  <div class="banner-wrapper">
    <img
      src="https://d5z5gg6ru5enr7l6wb6sdgcjdmju3qtap3eo4du77bry4udg2jiq.ardrive.net/H3PTG9GnSNj9frB9IZhJGxNNwmB-yO4On_hjjlBm0lE"
      alt="InFlow Banner"/>
  </div>

  <div class="lower-section">
    <!-- Mint Card -->
    <div class="box">
      <h1>Mint NFT</h1>
      <div class="form-group">
        <label for="power-select">Select Power & Price</label>
        <select id="power-select">
          <option value="1">1 — $S10</option>
          <option value="2">2 — $S20</option>
          <option value="3">3 — $S30</option>
          <option value="4">4 — $S40</option>
          <option value="5">5 — $S50</option>
          <option value="6">6 — $S60</option>
          <option value="7">7 — $S70</option>
          <option value="8">8 — $S80</option>
          <option value="9">9 — $S90</option>
          <option value="10">10 — $S100</option>
        </select>
        <button id="mint-button">Mint Now</button>
      </div>
      <div id="status">Disconnected</div>
    </div>

    <!-- Staking Card -->
    <div class="box">
      <h1>Stake & Unstake</h1>
      <div class="form-group">
        <label for="stake-select">Your NFTs (Power)</label>
        <select id="stake-select" multiple size="5"></select>
        <button id="stake-button">Stake Selected</button>
      </div>
      <div class="form-group">
        <label for="unstake-select">Staked NFTs</label>
        <select id="unstake-select" multiple size="5"></select>
        <button id="unstake-button">Unstake Selected</button>
      </div>
      <div class="info" id="staked-info">Staked NFTs: 0 | Power: 0</div>
      <div class="info" id="pending-rewards">Rewards: 0 S</div>
      <button id="claim-button">Claim Rewards</button>
      <div id="stake-status"></div>
    </div>

    <!-- Coming Soon Card -->
    <div class="box">
      <h1>Coming Soon</h1>
      <p class="info">Redeem utilities launching shortly!</p>
    </div>
  </div>

  <div class="socials">
    <a href="#" id="docs-link"><img src="PATH_TO_BOOK_ICON" alt="Docs"></a>
    <a href="#" id="x-link"><img src="PATH_TO_X_ICON" alt="X"></a>
    <a href="#" id="telegram-link"><img src="PATH_TO_TELEGRAM_ICON" alt="Telegram"></a>
  </div>
//comment out to disable debug
//  <div class="debug" id="debug-log" aria-hidden="false">debug</div>

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    const NFT_ADDRESS     = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;           // decimal
    const SONIC_CHAIN_ID_HEX = '0x3909';       // hex for 14601
    const SONIC_RPC = 'https://rpc.testnet.soniclabs.com';

    const NFT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenPower(uint256 tokenId) view returns (uint8)",
      "function feeForPower(uint8 power) view returns (uint256)",
      "function mint(uint8 power) payable",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)"
    ];

    const STAKING_ABI = [
      "function stake(uint256[])",
      "function unstake(uint256[])",
      "function claimRewards()",
      "function stakedTokensOf(address) view returns (uint256[])",
      "function pendingRewards(address) view returns (uint256)",
      "function totalPowerStaked(address) view returns (uint256)",
      "function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])"
    ];

    const SONIC_PARAMS = [{
      chainId: SONIC_CHAIN_ID_HEX,
      chainName: 'Sonic Testnet',
      nativeCurrency: { name: 'S', symbol: 'S', decimals: 18 },
      rpcUrls: [SONIC_RPC],
      blockExplorerUrls: ['https://testnet.sonicscan.org']
    }];

    let provider, signer, account;
    let nftContract, stakingContract, stakingRead;
    const debugEl = document.getElementById('debug-log');
    function dbg(...args) {
      console.log(...args);
      try {
        debugEl.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' | ');
      } catch {}
    }

    document.getElementById('mint-button').disabled = true;
    document.getElementById('claim-button').disabled = true;

    // helper: verify the RPC at SONIC_RPC returns the expected chainId
    async function rpcReportsCorrectChain() {
      try {
        const resp = await fetch(SONIC_RPC, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_chainId', params: [] })
        });
        const data = await resp.json();
        dbg('RPC eth_chainId response', data);
        if (data && data.result) {
          // result is hex string
          return parseInt(data.result, 16) === REQUIRED_CHAIN_ID;
        }
      } catch (e) {
        dbg('rpcReportsCorrectChain error', e);
      }
      return false;
    }

    // attempt to switch; if wallet complains chain unknown, attempt to add then switch
    async function trySwitchOrAdd() {
      if (!window.ethereum || !window.ethereum.request) {
        dbg('no window.ethereum');
        return false;
      }

      // sanity: if RPC doesn't report correct chain, bail early and show debug
      const rpcOk = await rpcReportsCorrectChain();
      dbg('rpcOk', rpcOk);
      if (!rpcOk) {
        dbg('RPC endpoint does not report expected chainId; check SONIC_RPC or try alternate RPC');
        document.getElementById('status').textContent = 'Sonic RPC mismatch';
        return false;
      }

      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: SONIC_CHAIN_ID_HEX }]
        });
        return true;
      } catch (err) {
        dbg('wallet_switchEthereumChain failed', err);
        const dataCode = err && err.data && err.data.code;
        const isUnrecognized = err && (err.code === 4902 || dataCode === 4902 || /Unrecognized chain/i.test(err.message || ''));
        if (isUnrecognized) {
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: SONIC_PARAMS
            });
            // retry switch
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: SONIC_CHAIN_ID_HEX }]
            });
            return true;
          } catch (addErr) {
            dbg('wallet_addEthereumChain failed', addErr);
            return false;
          }
        }
        return false;
      }
    }

    async function connectWallet() {
      dbg('connectWallet start', { hasWindowEthereum: !!window.ethereum });
      if (!window.ethereum) {
        alert('Please install a Web3 wallet');
        return;
      }
      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        dbg('accounts', accounts);
        await handleAccountsChanged(accounts);
      } catch (e) {
        dbg('eth_requestAccounts error', e);
        document.getElementById('status').textContent = 'Connection rejected';
      }
    }

    async function handleAccountsChanged(accounts) {
      dbg('handleAccountsChanged', accounts);
      if (!accounts || accounts.length === 0) {
        disconnect();
        return;
      }

      provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      signer   = provider.getSigner();

      try {
        account = await signer.getAddress();
      } catch (e) {
        dbg('getAddress failed', e);
        document.getElementById('status').textContent = 'Wallet error';
        return;
      }

      // get current chain; if wrong, try to add/switch
      let net;
      try {
        net = await provider.getNetwork();
        dbg('provider network', net);
      } catch (e) {
        dbg('getNetwork failed', e);
      }

      if (!net || net.chainId !== REQUIRED_CHAIN_ID) {
        const ok = await trySwitchOrAdd();
        if (!ok) {
          document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
          return;
        }
        // refresh provider network after switch
        try { net = await provider.getNetwork(); dbg('network after switch', net); } catch (e) { dbg('getNetwork after switch failed', e); }
        if (!net || net.chainId !== REQUIRED_CHAIN_ID) {
          document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
          return;
        }
      }

      document.getElementById('wallet-button').textContent = '…' + account.slice(-4);
      document.getElementById('status').textContent        = 'Connected';
      document.getElementById('mint-button').disabled      = false;
      document.getElementById('claim-button').disabled     = false;

      nftContract     = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
      stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead     = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, provider);

      attachHandlers();
      try { await populateOwned(); } catch (e) { dbg('populateOwned failed', e); }
      try { await populateStaked(); } catch (e) { dbg('populateStaked failed', e); }
      try { await updateStats(); } catch (e) { dbg('updateStats failed', e); }
    }

    function disconnect() {
      dbg('disconnecting');
      account = signer = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    document.getElementById('wallet-button').onclick = connectWallet;

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          const cost = await nftContract.feeForPower(p);
          const tx   = await nftContract.mint(p, { value: cost });
          document.getElementById('status').textContent = 'Minting…';
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          dbg('mint error', e);
          document.getElementById('status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(document.getElementById('stake-select').selectedOptions).map(o => +o.value);
        if (!ids.length) return;
        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          const approved = await nftContract.isApprovedForAll(account, STAKING_ADDRESS);
          if (!approved) {
            document.getElementById('stake-status').textContent = 'Approving…';
            const txA = await nftContract.setApprovalForAll(STAKING_ADDRESS, true);
            await txA.wait();
          }
          document.getElementById('stake-status').textContent = 'Staking…';
          const tx = await stakingContract.stake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          dbg('stake error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(document.getElementById('unstake-select').selectedOptions).map(o => +o.value);
        if (!ids.length) return;
        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          const tx = await stakingContract.unstake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          dbg('unstake error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          const tx = await stakingContract.claimRewards();
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Claimed!';
          await updateStats();
        } catch (e) {
          dbg('claim error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      try {
        const bal = await nftContract.balanceOf(account);
        for (let i = 0; i < bal; i++) {
          const id = await nftContract.tokenOfOwnerByIndex(account, i);
          const p  = await nftContract.tokenPower(id);
          const o  = document.createElement('option');
          o.value  = id.toString();
          o.textContent = `#${id} (Power: ${p})`;
          sel.append(o);
        }
      } catch (e) {
        dbg('populateOwned failed', e);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [, , , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id, i) => {
          const o = document.createElement('option');
          o.value = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        dbg('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw, tokenIds, powers] = await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent = `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent = `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
        dbg("Detailed position:", tokenIds.map((id, i) => ({ tokenId: id.toString(), power: powers[i] })));
      } catch (e) {
        dbg('updateStats failed', e);
      }
    }

    // show provider status on load
    window.addEventListener('load', async () => {
      try {
        dbg('window.ethereum', { present: !!window.ethereum, providerType: window.ethereum && window.ethereum.request ? 'EIP-1193' : 'unknown' });
        const rpcOk = await rpcReportsCorrectChain();
        dbg('SONIC_RPC reports expected chainId?', rpcOk);
      } catch (e) { dbg('load error', e); }
    });
  </script>
</body>
</html>

