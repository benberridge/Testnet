<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net https://cdn.skypack.dev 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://*.ardrive.net;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
    rel="stylesheet"/>
  <style>
    :root {
      --neon: #00ffe1;
      --neon-dim: rgba(0,255,225,0.2);
      --text-light: #e0e0e0;
      --card-bg: rgba(255,255,255,0.05);
      --radius: 16px;
      --gap: 1.5rem;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at center,#1a1a3d,#0a0a1f);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      padding: var(--gap);
      line-height: 1.4;
    }
    .brand {
      text-align: center;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--neon);
      text-shadow: 0 0 8px var(--neon), 0 0 16px var(--neon);
      margin-bottom: var(--gap);
      letter-spacing: 2px;
    }
    #wallet-button {
      position: fixed; top: var(--gap); right: var(--gap);
      padding: .6rem 1.2rem;
      border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: var(--radius);
      font-weight: 500; cursor: pointer;
      transition: background var(--transition), color var(--transition);
      z-index: 10;
    }
    #wallet-button:hover { background: var(--neon-dim); color: #fff; }
    .banner-wrapper {
      max-width: 300px; margin: 0 auto calc(var(--gap)*1.5);
      border-radius: var(--radius); overflow: hidden;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
    .banner-wrapper img { width: 100%; display: block; }
    .lower-section {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(320px,1fr));
      gap: var(--gap);
    }
    .box {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: var(--radius);
      padding: var(--gap);
      display: flex; flex-direction: column;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .box:hover {
      transform: translateY(-6px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    h1 {
      font-size: 1.8rem; font-weight: 700;
      color: var(--neon); text-align: center;
      margin-bottom: 1rem;
      text-shadow: 0 0 4px var(--neon);
    }
    label {
      font-weight: 500; margin-bottom: .5rem;
      color: var(--text-light);
    }
    select, input {
      width: 100%; padding: .6rem; margin-bottom: 1rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      color: var(--text-light);
      font-size: 1rem;
      transition: border var(--transition);
    }
    select:focus, input:focus { outline: none; border-color: var(--neon); }
    button {
      padding: .75rem; border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: 8px; font-weight: 500;
      cursor: pointer;
      transition: background var(--transition), color var(--transition);
      margin: 0 auto;
    }
    button:hover { background: var(--neon-dim); color: #fff; }
    .form-group {
      flex: 1; display: flex; flex-direction: column; align-items: center;
    }
    .info { text-align: center; margin: .75rem 0; font-size: .95rem; }
    #status, #stake-status {
      text-align: center; margin-top: .5rem;
      min-height: 1.2em; font-size: .9rem; color: var(--neon);
    }
    .socials { text-align: center; margin-top: var(--gap); }
    .socials a { margin: 0 .5rem; display: inline-block; }
    .socials img {
      width: 28px; height: 28px;
      filter: drop-shadow(0 0 4px var(--neon));
    }
  </style>
</head>
<body>
  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>

  <div class="banner-wrapper">
    <img
      src="https://d5z5gg6ru5enr7l6wb6sdgcjdmju3qtap3eo4du77bry4udg2jiq.ardrive.net/H3PTG9GnSNj9frB9IZhJGxNNwmB-yO4On_hjjlBm0lE"
      alt="InFlow Banner"/>
  </div>

  <div class="lower-section">
    <!-- Mint Card -->
    <div class="box">
      <h1>Mint NFT</h1>
      <div class="form-group">
        <label for="power-select">Select Power & Price</label>
        <select id="power-select">
          <option value="1">1 — $S10</option>
          <option value="2">2 — $S20</option>
          <option value="3">3 — $S30</option>
          <option value="4">4 — $S40</option>
          <option value="5">5 — $S50</option>
          <option value="6">6 — $S60</option>
          <option value="7">7 — $S70</option>
          <option value="8">8 — $S80</option>
          <option value="9">9 — $S90</option>
          <option value="10">10 — $S100</option>
        </select>
        <button id="mint-button">Mint Now</button>
      </div>
      <div id="status">Disconnected</div>
    </div>

    <!-- Staking Card -->
    <div class="box">
      <h1>Stake & Unstake</h1>
      <div class="form-group">
        <label for="stake-select">Your NFTs (Power)</label>
        <select id="stake-select" multiple size="5"></select>
        <button id="stake-button">Stake Selected</button>
      </div>
      <div class="form-group">
        <label for="unstake-select">Staked NFTs</label>
        <select id="unstake-select" multiple size="5"></select>
        <button id="unstake-button">Unstake Selected</button>
      </div>
      <div class="info" id="staked-info">Staked NFTs: 0 | Power: 0</div>
      <div class="info" id="pending-rewards">Rewards: 0 S</div>
      <button id="claim-button">Claim Rewards</button>
      <div id="stake-status"></div>
    </div>

    <!-- Coming Soon Card -->
    <div class="box">
      <h1>Coming Soon</h1>
      <p class="info">Redeem utilities launching shortly!</p>
    </div>
  </div>

  <div class="socials">
    <a href="#" id="docs-link"><img src="PATH_TO_BOOK_ICON" alt="Docs"></a>
    <a href="#" id="x-link"><img src="PATH_TO_X_ICON" alt="X"></a>
    <a href="#" id="telegram-link"><img src="PATH_TO_TELEGRAM_ICON" alt="Telegram"></a>
  </div>

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';
    import {
      createClient,
      configureChains,
      watchAccount,
      watchNetwork
    } from 'https://cdn.skypack.dev/@wagmi/core';
    import { publicProvider } from 'https://cdn.skypack.dev/@wagmi/core/providers/public';
    import { InjectedConnector } from 'https://cdn.skypack.dev/@wagmi/core/connectors/injected';

    // Sonic Testnet config
    const sonicTestnet = {
      id: 14601,
      name: 'Sonic Testnet',
      network: 'sonic-testnet',
      nativeCurrency: { name: 'Sonic', symbol: 'S', decimals: 18 },
      rpcUrls: { default: 'https://rpc.testnet.soniclabs.com' }
    };

    // Wagmi client setup
    const { chains, provider } = configureChains(
      [sonicTestnet],
      [publicProvider()]
    );
    const injectedConnector = new InjectedConnector({ chains });
    const client = createClient({
      autoConnect: true,
      connectors: [injectedConnector],
      provider
    });

    const NFT_ADDRESS       = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS   = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;

    const NFT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenPower(uint256 tokenId) view returns (uint8)",
      "function feeForPower(uint8 power) view returns (uint256)",
      "function mint(uint8 power) payable",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)"
    ];
    const STAKING_ABI = [
      "function stake(uint256[])",
      "function unstake(uint256[])",
      "function claimRewards()",
      "function stakedTokensOf(address) view returns (uint256[])",
      "function pendingRewards(address) view returns (uint256)",
      "function totalPowerStaked() view returns (uint256)",
      "function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])"
    ];

    let providerEthers, signer, account;
    let nftContract, stakingContract, stakingRead;

    document.getElementById('mint-button').disabled = true;
    document.getElementById('claim-button').disabled = true;

    // Connect wallet handler
    document.getElementById('wallet-button').onclick = async () => {
      console.log('🔹 Connect clicked');
      try {
        const data = await client.connect({ connector: injectedConnector });
        console.log('✅ Wagmi.connect:', data);
      } catch (err) {
        console.error('❌ Wagmi.connect failed:', err);
      }
    };

    watchAccount(({ address, isConnected }) => {
      if (isConnected && address) {
        account = address;
        initializeEthers();
      } else {
        disconnect();
      }
    });
    watchNetwork(({ chain }) => {
      if (chain?.id !== REQUIRED_CHAIN_ID) {
        document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
      }
    });

    async function initializeEthers() {
      const wagmiProvider = provider();
      providerEthers = new ethers.providers.Web3Provider(wagmiProvider, 'any');
      signer = providerEthers.getSigner();

      document.getElementById('wallet-button').textContent = '…' + account.slice(-4);
      document.getElementById('status').textContent        = 'Connected';
      document.getElementById('mint-button').disabled      = false;
      document.getElementById('claim-button').disabled     = false;

      nftContract     = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
      stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead     = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, providerEthers);

      attachHandlers();
      await populateOwned();
      await populateStaked();
      await updateStats();
    }

    function disconnect() {
      account = signer = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          const cost = await nftContract.feeForPower(p);
          const tx   = await nftContract.mint(p, { value: cost });
          document.getElementById('status').textContent = 'Minting…';
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('status').textContent = e.message;
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('stake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          const approved = await nftContract.isApprovedForAll(account, STAKING_ADDRESS);
          if (!approved) {
            document.getElementById('stake-status').textContent = 'Approving…';
            const txA = await nftContract.setApprovalForAll(STAKING_ADDRESS, true);
            await txA.wait();
          }

          document.getElementById('stake-status').textContent = 'Staking…';
          const tx = await stakingContract.stake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('unstake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          const tx = await stakingContract.unstake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await populateOwned();
          await populateStaked();
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          const tx = await stakingContract.claimRewards();
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Claimed!';
          await updateStats();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      const bal = await nftContract.balanceOf(account);
      for (let i = 0; i < bal; i++) {
        const id = await nftContract.tokenOfOwnerByIndex(account, i);
        const p  = await nftContract.tokenPower(id);
        const o  = document.createElement('option');
        o.value      = id.toString();
        o.textContent = `#${id} (Power: ${p})`;
        sel.append(o);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [, , , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id, i) => {
          const o = document.createElement('option');
          o.value      = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        console.error('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw] =
          await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent =
          `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent =
          `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
      } catch (e) {
        console.error('updateStats failed', e);
      }
    }
  </script>
</body>
</html>
