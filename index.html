<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net https://esm.sh 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data:;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
    rel="stylesheet"/>
  <style>
    :root {
      --neon: #00ffe1;
      --neon-dim: rgba(0,255,225,0.2);
      --text-light: #e0e0e0;
      --card-bg: rgba(255,255,255,0.05);
      --radius: 16px;
      --gap: 1.5rem;
      --transition: 0.3s ease;
    }
    * { box-sizing: border-box; margin: 0; padding: 0 }
    body {
      background: radial-gradient(circle at center, #1a1a3d, #0a0a1f);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      padding: var(--gap);
      line-height: 1.4;
    }
    .brand {
      text-align: center;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--neon);
      text-shadow: 0 0 8px var(--neon), 0 0 16px var(--neon);
      margin-bottom: var(--gap);
      letter-spacing: 2px;
    }
    #wallet-button {
      position: fixed; top: var(--gap); right: var(--gap);
      padding: .6rem 1.2rem;
      border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: var(--radius);
      font-weight: 500; cursor: pointer;
      transition: background var(--transition), color var(--transition);
      z-index: 10;
    }
    #wallet-button:hover { background: var(--neon-dim); color: #fff }
    .lower-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px,1fr));
      gap: var(--gap);
    }
    .box {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: var(--radius);
      padding: var(--gap);
      display: flex; flex-direction: column;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .box:hover {
      transform: translateY(-6px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    h1 {
      font-size: 1.8rem; font-weight: 700;
      color: var(--neon); text-align: center;
      margin-bottom: 1rem;
      text-shadow: 0 0 4px var(--neon);
    }
    label {
      font-weight: 500; margin-bottom: .5rem;
      color: var(--text-light);
    }
    select, input {
      width: 100%; padding: .6rem; margin-bottom: 1rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      color: var(--text-light);
      font-size: 1rem;
      transition: border var(--transition);
    }
    select:focus, input:focus { outline: none; border-color: var(--neon); }
    button {
      padding: .75rem; border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: 8px; font-weight: 500;
      cursor: pointer;
      transition: background var(--transition), color var(--transition);
      margin: 0 auto;
    }
    button:hover { background: var(--neon-dim); color: #fff }
    .info { text-align: center; margin: .75rem 0; font-size: .95rem }
  </style>
</head>
<body>
  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>

  <div class="lower-section">
    <div class="box">
      <h1>Mint NFT</h1>
      <label for="power-select">Select Power & Price</label>
      <select id="power-select">
        <option value="1">1 — $S10</option>
        <option value="2">2 — $S20</option>
        <option value="3">3 — $S30</option>
        <option value="4">4 — $S40</option>
        <option value="5">5 — $S50</option>
        <option value="6">6 — $S60</option>
        <option value="7">7 — $S70</option>
        <option value="8">8 — $S80</option>
        <option value="9">9 — $S90</option>
        <option value="10">10 — $S100</option>
      </select>
      <button id="mint-button">Mint Now</button>
      <div id="status" class="info">Disconnected</div>
    </div>

    <div class="box">
      <h1>Stake & Unstake</h1>
      <label for="stake-select">Your NFTs (Power)</label>
      <select id="stake-select" multiple size="5"></select>
      <button id="stake-button">Stake Selected</button>

      <label for="unstake-select">Staked NFTs</label>
      <select id="unstake-select" multiple size="5"></select>
      <button id="unstake-button">Unstake Selected</button>

      <div id="staked-info" class="info">Staked NFTs: 0 | Power: 0</div>
      <div id="pending-rewards" class="info">Rewards: 0 S</div>
      <button id="claim-button">Claim Rewards</button>
      <div id="stake-status" class="info"></div>
    </div>

    <div class="box">
      <h1>Coming Soon</h1>
      <p class="info">Redeem utilities launching shortly!</p>
    </div>
  </div>

  <script type="module">
    // 1) ethers.js
    import { ethers }
      from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    // 2) Wagmi Core bundle (createClient, configureChains, watchAccount, watchNetwork, publicProvider)
    import {
      createClient,
      configureChains,
      watchAccount,
      watchNetwork,
      publicProvider
    } from 'https://esm.sh/@wagmi/core@2.21.2?bundle';

    // 3) Injected connector factory from jsDelivr (correct ESM path)
    import { injected }
      from 'https://cdn.jsdelivr.net/npm/@wagmi/connectors@0.4.14/dist/esm/injected/index.js';

    // Sonic Testnet configuration
    const sonicTestnet = {
      id: 14601,
      name: 'Sonic Testnet',
      network: 'sonic-testnet',
      nativeCurrency: { name: 'Sonic', symbol: 'S', decimals: 18 },
      rpcUrls: { default: 'https://rpc.testnet.soniclabs.com' }
    };

    // Build Wagmi client
    const { chains, provider } = configureChains(
      [sonicTestnet],
      [publicProvider()]
    );

    // Call the connector factory with your chains
    const connector = injected({ chains });

    const client = createClient({
      autoConnect: true,
      connectors: [connector],
      provider
    });

    // Contract addresses & ABIs
    const NFT_ADDRESS       = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS   = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;

    const NFT_ABI = [
      'function balanceOf(address) view returns (uint256)',
      'function tokenOfOwnerByIndex(address,uint256) view returns (uint256)',
      'function tokenPower(uint256) view returns (uint8)',
      'function feeForPower(uint8) view returns (uint256)',
      'function mint(uint8) payable',
      'function isApprovedForAll(address,address) view returns (bool)',
      'function setApprovalForAll(address,bool)'
    ];

    const STAKING_ABI = [
      'function stake(uint256[])',
      'function unstake(uint256[])',
      'function claimRewards()',
      'function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])'
    ];

    let signer, account;
    let nftContract, stakingContract, stakingRead;

    // Disable until wallet connects
    document.getElementById('mint-button').disabled  = true;
    document.getElementById('claim-button').disabled = true;

    // Connect Wallet button
    document.getElementById('wallet-button').onclick = async () => {
      try {
        await client.connect({ connector });
      } catch (err) {
        console.error('Connection failed:', err);
      }
    };

    // React to account/network changes
    watchAccount(({ address, isConnected }) => {
      if (isConnected && address) {
        account = address;
        initializeEthers();
      } else {
        teardown();
      }
    });

    watchNetwork(({ chain }) => {
      if (chain?.id !== REQUIRED_CHAIN_ID) {
        document.getElementById('status').textContent =
          'Please switch to Sonic Testnet';
      }
    });

    async function initializeEthers() {
      const wagmiProv = provider();
      const web3p     = new ethers.providers.Web3Provider(wagmiProv, 'any');
      signer          = web3p.getSigner();

      document.getElementById('wallet-button').textContent =
        '…' + account.slice(-4);
      document.getElementById('status').textContent = 'Connected';
      document.getElementById('mint-button').disabled  = false;
      document.getElementById('claim-button').disabled = false;

      nftContract     = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
      stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead     = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, web3p);

      attachHandlers();
      await refreshAll();
    }

    function teardown() {
      signer = account = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          document.getElementById('status').textContent = 'Minting…';
          const cost = await nftContract.feeForPower(p);
          const tx   = await nftContract.mint(p, { value: cost });
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await refreshAll();
        } catch (e) {
          document.getElementById('status').textContent = e.message;
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('stake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          if (!(await nftContract.isApprovedForAll(account, STAKING_ADDRESS))) {
            document.getElementById('stake-status').textContent = 'Approving…';
            await (await nftContract.setApprovalForAll(STAKING_ADDRESS, true)).wait();
          }
          document.getElementById('stake-status').textContent = 'Staking…';
          await (await stakingContract.stake(ids)).wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(
          document.getElementById('unstake-select').selectedOptions
        ).map(o => +o.value);
        if (!ids.length) return;

        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          await (await stakingContract.unstake(ids)).wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          await (await stakingContract.claimRewards()).wait();
          document.getElementById('stake-status').textContent = 'Claimed!';
          await refreshAll();
        } catch (e) {
          document.getElementById('stake-status').textContent = e.message;
        }
      };
    }

    async function refreshAll() {
      await populateOwned();
      await populateStaked();
      await updateStats();
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      const bal = await nftContract.balanceOf(account);
      for (let i = 0; i < bal; i++) {
        const id = await nftContract.tokenOfOwnerByIndex(account, i);
        const p  = await nftContract.tokenPower(id);
        const o  = document.createElement('option');
        o.value      = id.toString();
        o.textContent = `#${id} (Power: ${p})`;
        sel.append(o);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [, , , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id, i) => {
          const o = document.createElement('option');
          o.value      = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        console.error('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw] =
          await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent =
          `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent =
          `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
      } catch (e) {
        console.error('updateStats failed', e);
      }
    }
  </script>
</body>
</html>
