<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline';
      style-src 'self' https://fonts.googleapis.com 'unsafe-inline';
      connect-src 'self' https://rpc.testnet.soniclabs.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://*.ardrive.net;
    "/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InFlow</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet"/>
  <style>
    :root {
      --neon: #00ffe1;
      --neon-dim: rgba(0,255,225,0.2);
      --text-light: #e0e0e0;
      --card-bg: rgba(255,255,255,0.05);
      --radius: 16px;
      --gap: 1.5rem;
      --transition: 0.3s ease;
      --banner-h: 48px;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at center,#1a1a3d,#0a0a1f);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      padding: calc(var(--gap) + var(--banner-h)) var(--gap) var(--gap);
      line-height: 1.4;
    }

    /* Rolling banner (fixed top) */
    .top-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--banner-h);
      background: linear-gradient(90deg, rgba(0,0,0,0.45), rgba(0,0,0,0.25));
      border-bottom: 1px solid rgba(255,255,255,0.06);
      display: flex;
      align-items: center;
      overflow: hidden;
      z-index: 1000;
      padding: 0 1rem;
      backdrop-filter: blur(6px);
    }
    .ticker {
      display: inline-block;
      white-space: nowrap;
      will-change: transform;
      transform: translateX(100%); /* ensure consistent start position to avoid jump */
      animation: scroll-left 36s linear infinite;
      animation-play-state: paused; /* prevent initial glitch; start when data loaded */
      font-weight: 500;
      color: var(--text-light);
      font-size: 0.95rem;
    }
    .ticker.running { animation-play-state: running; }
    @keyframes scroll-left {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-100%); }
    }
    .stat-pill {
      display: inline-block;
      background: rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.04);
      padding: 6px 12px;
      margin-right: 12px;
      border-radius: 999px;
      color: var(--neon);
      box-shadow: 0 0 8px rgba(0,255,225,0.04);
    }

    .brand {
      text-align: center;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--neon);
      text-shadow: 0 0 8px var(--neon), 0 0 16px var(--neon);
      margin-bottom: var(--gap);
      letter-spacing: 2px;
    }
    /* Lower connect button so it's directly below the banner */
    #wallet-button {
      position: fixed; top: calc(var(--banner-h) + 8px); right: var(--gap);
      padding: .6rem 1.2rem;
      border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: var(--radius);
      font-weight: 500; cursor: pointer;
      transition: background var(--transition), color var(--transition);
      z-index: 1101; /* higher than .top-banner (1000) so button appears above it */
    }
    #wallet-button:hover { background: var(--neon-dim); color: #fff; }
    .banner-wrapper {
      max-width: 300px; margin: 0 auto calc(var(--gap)*1.5);
      border-radius: var(--radius); overflow: hidden;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
    .banner-wrapper img { width: 100%; display: block; }
    .lower-section {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(320px,1fr));
      gap: var(--gap);
    }
    .box {
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: var(--radius);
      padding: var(--gap);
      display: flex; flex-direction: column;
      transition: transform var(--transition), box-shadow var(--transition);
    }
    .box:hover {
      transform: translateY(-6px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    h1 {
      font-size: 1.8rem; font-weight: 700;
      color: var(--neon); text-align: center;
      margin-bottom: 1rem;
      text-shadow: 0 0 4px var(--neon);
    }
    label {
      font-weight: 500; margin-bottom: .5rem;
      color: var(--text-light);
    }
    select, input {
      width: 100%; padding: .6rem; margin-bottom: 1rem;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      color: var(--text-light);
      font-size: 1rem;
      transition: border var(--transition);
    }
    select:focus, input:focus { outline: none; border-color: var(--neon); }
    button {
      padding: .75rem; border: 2px solid var(--neon);
      background: transparent; color: var(--neon);
      border-radius: 8px; font-weight: 500;
      cursor: pointer;
      transition: background var(--transition), color var(--transition);
      margin: 0 auto;
    }
    button:hover { background: var(--neon-dim); color: #fff; }
    .form-group {
      flex: 1; display: flex; flex-direction: column; align-items: center;
    }
    .info { text-align: center; margin: .75rem 0; font-size: .95rem; }
    #status, #stake-status {
      text-align: center; margin-top: .5rem;
      min-height: 1.2em; font-size: .9rem; color: var(--neon);
    }
    .socials { text-align: center; margin-top: var(--gap); }
    .socials a { margin: 0 .5rem; display: inline-block; }
    .socials img {
      width: 28px; height: 28px;
      filter: drop-shadow(0 0 4px var(--neon));
    }
    .debug { position: fixed; left: 12px; bottom: 12px; background: rgba(0,0,0,0.6); color: #fff; padding: .5rem .75rem; border-radius: 8px; font-size: .85rem; max-width: 40%; z-index: 9999; overflow: auto; max-height: 30vh; }
    @media (max-width: 600px) {
      .ticker { animation-duration: 52s; font-size: 0.85rem; } /* mobile slowed 50%: was 26s -> now 52s */
      body { padding-top: calc(var(--banner-h) + 12px); }
    }
  </style>
</head>
<body>
  <div class="top-banner" aria-hidden="false">
    <div class="ticker" id="rolling-stats">
      <span class="stat-pill">Total NFTs minted: <span id="stat-total-nfts">—</span></span>
      <span class="stat-pill">Total power minted: <span id="stat-total-power-minted">—</span></span>
      <span class="stat-pill">Total Invested: <span id="stat-total-invested">—</span></span>
      <span class="stat-pill">Total NFTs staked: <span id="stat-total-nfts-staked">—</span></span>
      <span class="stat-pill">Total power staked: <span id="stat-total-power-staked">—</span></span>
      <span class="stat-pill">Total rewards distributed: <span id="stat-total-rewards-distributed">N/A</span></span>
    </div>
  </div>

  <div class="brand">InFlow</div>
  <button id="wallet-button">Connect Wallet</button>

  <div class="banner-wrapper">
    <img
      src="https://d5z5gg6ru5enr7l6wb6sdgcjdmju3qtap3eo4du77bry4udg2jiq.ardrive.net/H3PTG9GnSNj9frB9IZhJGxNNwmB-yO4On_hjjlBm0lE"
      alt="InFlow Banner"/>
  </div>

  <div class="lower-section">
    <!-- Mint Card -->
    <div class="box">
      <h1>Mint NFT</h1>
      <div class="form-group">
        <label for="power-select">Select Power & Price</label>
        <select id="power-select">
          <option value="1">1 — $S10</option>
          <option value="2">2 — $S20</option>
          <option value="3">3 — $S30</option>
          <option value="4">4 — $S40</option>
          <option value="5">5 — $S50</option>
          <option value="6">6 — $S60</option>
          <option value="7">7 — $S70</option>
          <option value="8">8 — $S80</option>
          <option value="9">9 — $S90</option>
          <option value="10">10 — $S100</option>
        </select>
        <button id="mint-button">Mint Now</button>
      </div>
      <div id="status">Disconnected</div>
    </div>

    <!-- Staking Card -->
    <div class="box">
      <h1>Stake & Unstake</h1>
      <div class="form-group">
        <label for="stake-select">Your NFTs (Power)</label>
        <select id="stake-select" multiple size="5"></select>
        <button id="stake-button">Stake Selected</button>
      </div>
      <div class="form-group">
        <label for="unstake-select">Staked NFTs</label>
        <select id="unstake-select" multiple size="5"></select>
        <button id="unstake-button">Unstake Selected</button>
      </div>
      <div class="info" id="staked-info">Staked NFTs: 0 | Power: 0</div>
      <div class="info" id="pending-rewards">Rewards: 0 S</div>
      <button id="claim-button">Claim Rewards</button>
      <div id="stake-status"></div>
    </div>

    <!-- Coming Soon Card -->
    <div class="box">
      <h1>Coming Soon</h1>
      <p class="info">Redeem utilities launching shortly!</p>
    </div>
  </div>

  <div class="socials">
    <a href="#" id="docs-link"><img src="PATH_TO_BOOK_ICON" alt="Docs"></a>
    <a href="#" id="x-link"><img src="PATH_TO_X_ICON" alt="X"></a>
    <a href="#" id="telegram-link"><img src="PATH_TO_TELEGRAM_ICON" alt="Telegram"></a>
  </div>
<!--comment out to disable debug -->
<!-- <div class="debug" id="debug-log" aria-hidden="false">debug</div> -->

  <script type="module">
    import { ethers } from 'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js';

    const NFT_ADDRESS     = '0xBA1636Ba8627D1f1e50FEdaf74F1A54DAAd83EE8';
    const STAKING_ADDRESS = '0x7c21F33b651870A63ecAd4E2710E1B56061C7D36';
    const REQUIRED_CHAIN_ID = 14601;           // decimal
    const SONIC_CHAIN_ID_HEX = '0x3909';       // hex for 14601
    const SONIC_RPC = 'https://rpc.testnet.soniclabs.com';
    const PRECISION = ethers.BigNumber.from("1000000000000000000");

    // Expanded ABIs for reading needed stats (added accRewardPerPower)
    const NFT_ABI = [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenPower(uint256 tokenId) view returns (uint8)",
      "function feeForPower(uint8 power) view returns (uint256)",
      "function mint(uint8 power) payable",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)",
      "function totalSupply() view returns (uint256)",
      "function getTotalPowerMinted() view returns (uint256)",
      "function basePrice() view returns (uint256)"
    ];

    const STAKING_ABI = [
      "function stake(uint256[])",
      "function unstake(uint256[])",
      "function claimRewards()",
      "function stakedTokensOf(address) view returns (uint256[])",
      "function pendingRewards(address) view returns (uint256)",
      "function totalPowerStaked() view returns (uint256)",
      "function totalNFTsStaked() view returns (uint256)",
      "function accRewardPerPower() view returns (uint256)",
      "function getUserStake(address) view returns (uint256,uint256,uint256,uint256[],uint8[])"
    ];

    const SONIC_PARAMS = [{
      chainId: SONIC_CHAIN_ID_HEX,
      chainName: 'Sonic Testnet',
      nativeCurrency: { name: 'S', symbol: 'S', decimals: 18 },
      rpcUrls: [SONIC_RPC],
      blockExplorerUrls: ['https://testnet.sonicscan.org']
    }];

    let provider, signer, account;
    let nftContract, stakingContract, stakingRead;
    const debugEl = document.getElementById('debug-log');
    function dbg(...args) {
      console.log(...args);
      try {
        if (debugEl) debugEl.textContent = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' | ');
      } catch {}
    }

    document.getElementById('mint-button').disabled = true;
    document.getElementById('claim-button').disabled = true;

    async function rpcReportsCorrectChain() {
      try {
        const resp = await fetch(SONIC_RPC, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_chainId', params: [] })
        });
        const data = await resp.json();
        dbg('RPC eth_chainId response', data);
        if (data && data.result) {
          return parseInt(data.result, 16) === REQUIRED_CHAIN_ID;
        }
      } catch (e) {
        dbg('rpcReportsCorrectChain error', e);
      }
      return false;
    }

    async function trySwitchOrAdd() {
      if (!window.ethereum || !window.ethereum.request) {
        dbg('no window.ethereum');
        return false;
      }
      const rpcOk = await rpcReportsCorrectChain();
      dbg('rpcOk', rpcOk);
      if (!rpcOk) {
        document.getElementById('status').textContent = 'Sonic RPC mismatch';
        return false;
      }
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: SONIC_CHAIN_ID_HEX }]
        });
        return true;
      } catch (err) {
        dbg('wallet_switchEthereumChain failed', err);
        const dataCode = err && err.data && err.data.code;
        const isUnrecognized = err && (err.code === 4902 || dataCode === 4902 || /Unrecognized chain/i.test(err.message || ''));
        if (isUnrecognized) {
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: SONIC_PARAMS
            });
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: SONIC_CHAIN_ID_HEX }]
            });
            return true;
          } catch (addErr) {
            dbg('wallet_addEthereumChain failed', addErr);
            return false;
          }
        }
        return false;
      }
    }

    async function connectWallet() {
      dbg('connectWallet start', { hasWindowEthereum: !!window.ethereum });
      if (!window.ethereum) {
        alert('Please install a Web3 wallet');
        return;
      }
      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        dbg('accounts', accounts);
        await handleAccountsChanged(accounts);
      } catch (e) {
        dbg('eth_requestAccounts error', e);
        document.getElementById('status').textContent = 'Connection rejected';
      }
    }

    async function handleAccountsChanged(accounts) {
      dbg('handleAccountsChanged', accounts);
      if (!accounts || accounts.length === 0) {
        disconnect();
        return;
      }

      provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
      signer   = provider.getSigner();

      try {
        account = await signer.getAddress();
      } catch (e) {
        dbg('getAddress failed', e);
        document.getElementById('status').textContent = 'Wallet error';
        return;
      }

      // get current chain; if wrong, try to add/switch
      let net;
      try {
        net = await provider.getNetwork();
        dbg('provider network', net);
      } catch (e) {
        dbg('getNetwork failed', e);
      }

      if (!net || net.chainId !== REQUIRED_CHAIN_ID) {
        const ok = await trySwitchOrAdd();
        if (!ok) {
          document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
          return;
        }
        try { net = await provider.getNetwork(); dbg('network after switch', net); } catch (e) { dbg('getNetwork after switch failed', e); }
        if (!net || net.chainId !== REQUIRED_CHAIN_ID) {
          document.getElementById('status').textContent = 'Please switch to Sonic Testnet';
          return;
        }
      }

      document.getElementById('wallet-button').textContent = '…' + account.slice(-4);
      document.getElementById('status').textContent        = 'Connected';
      document.getElementById('mint-button').disabled      = false;
      document.getElementById('claim-button').disabled     = false;

      nftContract     = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
      stakingContract = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
      stakingRead     = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, provider);

      attachHandlers();
      try { await populateOwned(); } catch (e) { dbg('populateOwned failed', e); }
      try { await populateStaked(); } catch (e) { dbg('populateStaked failed', e); }
      try { await updateStats(); } catch (e) { dbg('updateStats failed', e); }
    }

    function disconnect() {
      dbg('disconnecting');
      account = signer = nftContract = stakingContract = stakingRead = null;
      document.getElementById('wallet-button').textContent    = 'Connect Wallet';
      document.getElementById('status').textContent           = 'Disconnected';
      document.getElementById('mint-button').disabled         = true;
      document.getElementById('stake-select').innerHTML       = '';
      document.getElementById('unstake-select').innerHTML     = '';
      document.getElementById('staked-info').textContent      = 'Staked NFTs: 0 | Power: 0';
      document.getElementById('pending-rewards').textContent  = 'Rewards: 0 S';
      document.getElementById('stake-status').textContent     = '';
      document.getElementById('claim-button').disabled        = true;
    }

    document.getElementById('wallet-button').onclick = connectWallet;

    function attachHandlers() {
      document.getElementById('mint-button').onclick = async () => {
        const p = +document.getElementById('power-select').value;
        try {
          const cost = await nftContract.feeForPower(p);
          const tx   = await nftContract.mint(p, { value: cost });
          document.getElementById('status').textContent = 'Minting…';
          await tx.wait();
          document.getElementById('status').textContent = 'Mint successful!';
          await populateOwned();
          await populateStaked();
          await refreshBannerStats();
          await updateStats();
        } catch (e) {
          dbg('mint error', e);
          document.getElementById('status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('stake-button').onclick = async () => {
        const ids = Array.from(document.getElementById('stake-select').selectedOptions).map(o => +o.value);
        if (!ids.length) return;
        try {
          document.getElementById('stake-status').textContent = 'Checking approval…';
          const approved = await nftContract.isApprovedForAll(account, STAKING_ADDRESS);
          if (!approved) {
            document.getElementById('stake-status').textContent = 'Approving…';
            const txA = await nftContract.setApprovalForAll(STAKING_ADDRESS, true);
            await txA.wait();
          }
          document.getElementById('stake-status').textContent = 'Staking…';
          const tx = await stakingContract.stake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Staked!';
          await populateOwned();
          await populateStaked();
          await refreshBannerStats();
          await updateStats();
        } catch (e) {
          dbg('stake error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('unstake-button').onclick = async () => {
        const ids = Array.from(document.getElementById('unstake-select').selectedOptions).map(o => +o.value);
        if (!ids.length) return;
        try {
          document.getElementById('stake-status').textContent = 'Unstaking…';
          const tx = await stakingContract.unstake(ids);
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Unstaked!';
          await populateOwned();
          await populateStaked();
          await refreshBannerStats();
          await updateStats();
        } catch (e) {
          dbg('unstake error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };

      document.getElementById('claim-button').onclick = async () => {
        try {
          document.getElementById('stake-status').textContent = 'Claiming…';
          const tx = await stakingContract.claimRewards();
          await tx.wait();
          document.getElementById('stake-status').textContent = 'Claimed!';          await refreshBannerStats();
          await updateStats();
        } catch (e) {
          dbg('claim error', e);
          document.getElementById('stake-status').textContent = e && e.message ? e.message : String(e);
        }
      };
    }

    async function populateOwned() {
      const sel = document.getElementById('stake-select');
      sel.innerHTML = '';
      try {
        const bal = await nftContract.balanceOf(account);
        for (let i = 0; i < bal; i++) {
          const id = await nftContract.tokenOfOwnerByIndex(account, i);
          const p  = await nftContract.tokenPower(id);
          const o  = document.createElement('option');
          o.value  = id.toString();
          o.textContent = `#${id} (Power: ${p})`;
          sel.append(o);
        }
      } catch (e) {
        dbg('populateOwned failed', e);
      }
    }

    async function populateStaked() {
      const sel = document.getElementById('unstake-select');
      sel.innerHTML = '';
      try {
        const [, , , tokenIds, powers] = await stakingRead.getUserStake(account);
        tokenIds.forEach((id, i) => {
          const o = document.createElement('option');
          o.value = id.toString();
          o.textContent = `#${id} (Power: ${powers[i]})`;
          sel.append(o);
        });
      } catch (e) {
        dbg('populateStaked failed', e);
      }
    }

    async function updateStats() {
      try {
        const [nftCount, powerStaked, pendingRaw, tokenIds, powers] = await stakingRead.getUserStake(account);
        document.getElementById('staked-info').textContent = `Staked NFTs: ${nftCount.toNumber()} | Power: ${powerStaked.toNumber()}`;
        document.getElementById('pending-rewards').textContent = `Rewards: ${ethers.utils.formatUnits(pendingRaw, 18)} S`;
        dbg("Detailed position:", tokenIds.map((id, i) => ({ tokenId: id.toString(), power: powers[i] })));
      } catch (e) {
        dbg('updateStats failed', e);
      }
    }

    // Refresh banner (protocol-level) stats
    async function refreshBannerStats() {
      try {
        // Use a read-only provider if available, otherwise provider
        const readProvider = provider || new ethers.providers.JsonRpcProvider(SONIC_RPC);

        const nftRead = new ethers.Contract(NFT_ADDRESS, NFT_ABI, readProvider);
        const stakingReadLocal = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);

        // total NFTs minted (ERC721Enumerable.totalSupply)
        let totalNfts = '—';
        try {
          const ts = await nftRead.totalSupply();
          totalNfts = ts.toString();
          document.getElementById('stat-total-nfts').textContent = totalNfts;
        } catch (e) {
          dbg('totalSupply read failed', e);
          document.getElementById('stat-total-nfts').textContent = 'N/A';
        }

        // total power minted (contract getter) - keep as BN for later calc
        let totalPowerMinted = null;
        try {
          const tpm = await nftRead.getTotalPowerMinted();
          totalPowerMinted = tpm; // BigNumber
          document.getElementById('stat-total-power-minted').textContent = tpm.toString();
        } catch (e) {
          dbg('getTotalPowerMinted read failed', e);
          document.getElementById('stat-total-power-minted').textContent = 'N/A';
        }

        // basePrice (per power) and calculate invested = totalPowerMinted * basePrice
        try {
          const bp = await nftRead.basePrice();
          if (bp && totalPowerMinted) {
            const investedWei = bp.mul(totalPowerMinted);
            const investedInS = ethers.utils.formatUnits(investedWei, 18);
            const investedNoDecimals = investedInS.split('.')[0];
            document.getElementById('stat-total-invested').textContent = '$S ' + investedNoDecimals;
          } else {
            document.getElementById('stat-total-invested').textContent = 'N/A';
          }
        } catch (e) {
          dbg('basePrice or invested calc failed', e);
          document.getElementById('stat-total-invested').textContent = 'N/A';
        }

        // total NFTs staked & total power staked
        try {
          let totalNftsStaked = '—';
          let totalPowerStaked = '—';
          try {
            const tns = await stakingReadLocal.totalNFTsStaked();
            totalNftsStaked = tns.toString();
            document.getElementById('stat-total-nfts-staked').textContent = totalNftsStaked;
          } catch (e) {
            dbg('totalNFTsStaked read failed', e);
            document.getElementById('stat-total-nfts-staked').textContent = 'N/A';
          }
          try {
            const tps = await stakingReadLocal.totalPowerStaked();
            totalPowerStaked = tps.toString();
            document.getElementById('stat-total-power-staked').textContent = totalPowerStaked;
          } catch (e) {
            dbg('totalPowerStaked read failed', e);
            document.getElementById('stat-total-power-staked').textContent = 'N/A';
          }
        } catch (e) {
          dbg('staking totals read failed', e);
          document.getElementById('stat-total-nfts-staked').textContent = 'N/A';
          document.getElementById('stat-total-power-staked').textContent = 'N/A';
        }

        // total rewards distributed — compute from accRewardPerPower * totalPowerMinted / PRECISION
        try {
          const acc = await stakingReadLocal.accRewardPerPower();
          if (acc && totalPowerMinted) {
            const totalRewardsWei = acc.mul(totalPowerMinted).div(PRECISION);
            const totalRewardsStr = ethers.utils.formatUnits(totalRewardsWei, 18).split('.')[0];
            document.getElementById('stat-total-rewards-distributed').textContent = '$S ' + totalRewardsStr;
          } else {
            // fallback to pool balance if we can't compute
            try {
              const bal = await readProvider.getBalance(STAKING_ADDRESS);
              const balStr = ethers.utils.formatUnits(bal, 18).split('.')[0];
              document.getElementById('stat-total-rewards-distributed').textContent = '$S ' + balStr + ' (pool)';
            } catch (e) {
              document.getElementById('stat-total-rewards-distributed').textContent = 'N/A';
            }
          }
        } catch (e) {
          dbg('rewards distributed compute failed', e);
          document.getElementById('stat-total-rewards-distributed').textContent = 'N/A';
        }

      } catch (e) {
        dbg('refreshBannerStats failed', e);
      }
    }

    // show provider status on load and refresh banner
    window.addEventListener('load', async () => {
      try {
        dbg('window.ethereum', { present: !!window.ethereum, providerType: window.ethereum && window.ethereum.request ? 'EIP-1193' : 'unknown' });
        const rpcOk = await rpcReportsCorrectChain();
        dbg('SONIC_RPC reports expected chainId?', rpcOk);
      } catch (e) { dbg('load error', e); }
      // initial banner refresh using JSON-RPC provider (no wallet required)
      await refreshBannerStats();
      // start ticker after initial stats refresh to avoid visual jump
      try {
        const ticker = document.getElementById('rolling-stats');
        if (ticker) ticker.classList.add('running');
      } catch (e) { dbg('ticker start failed', e); }
      // refresh periodically to keep rolling banner fresh
      setInterval(refreshBannerStats, 30_000);
    });
  </script>
</body>
</html>
